{
  "name": "Rex",
  "tagline": "Concatenative Elixir macro language.",
  "body": "# Rex - Concatenative elixir macro language.\r\n\r\n![rex](https://cloud.githubusercontent.com/assets/331/19221774/310460ee-8e0f-11e6-864b-0a4f2c34b5b2.png)\r\n\r\nRex is a [concatenative language](http://concatenative.org) built with Elixir macros.\r\n\r\nBeing powered by Elixir macros means that Rex has no parser of its own as it just\r\nuses valid Elixir syntax and thus can be embedded on any elixir program.\r\n\r\n## Installation\r\n\r\n[Available in Hex](https://hex.pm/packages/rex), the package can be installed as:\r\n\r\n  1. Add `rex` to your list of dependencies in `mix.exs`:\r\n\r\n    ```elixir\r\n    def deps do\r\n      [{:rex, \"~> 0.1.0\"}]\r\n    end\r\n    ```\r\n\r\n## Stack based\r\n\r\nRex is stack based, that is all Rex functions take a list and return another list.\r\n\r\nThe topmost element in a stack is the one at index zero, for example, for\r\n`[1, 2, 3]` the top of the stack is `1`. Most Rex functions will operate on\r\ntop-most elements as they need and then push the result back to the top.\r\n\r\n\r\nInside the `rex` macro, the `~>` operator indicates the order in which to push\r\nvalues or operators on to the top of the stack.\r\n\r\nFor example, `rex(1 ~> 2 ~> add)` would result on the following \r\n`[add, 2, 1]` stack that when executed will yield `[3]`.\r\n\r\nSo the `~>` allows post-fix notation (operands first, operator last) syntax.\r\nThis is the preferred way as most concatenative languages are postfix, but\r\nRex also has a `<~` operator which just pushes values in the reverse order:\r\n`rex(add <~ 2 <~ 1)` will result on `[add, 2, 1]`.\r\n\r\n\r\nThe following example uses functions from `Rex.Core` for stack manipulation\r\nand `Rex.Math` that defines aliases to standard elixir math operators.\r\n\r\n```elixir\r\niex> [4, 5] |> rex(3 ~> 2 ~> 1 ~> add ~> mul ~> swap)\r\n[4, 9, 5] \r\n```\r\n\r\nMore examples available as [tests](https://github.com/vic/rex/blob/master/test/rex_test.exs)\r\n\r\n## Words\r\n\r\nIn concatenative languages, functions are refered to as *words*.\r\n\r\nInside an Elixir module, once you have `include Rex`'d\r\nyou can call `drex` to define a new _word_ that acts either as a\r\n*stack shuffler* or as an *operator on the stack*.\r\n\r\nTo define a stack *shuffling* word, the syntax is:\r\n\r\n```elixir\r\n    # (example from `Rex.Stack.swap/1`)\r\n    drex swap(a, b)     (b, a)\r\n```\r\n\r\n\r\nTo define a stack *operator* you use the `~>` or `<~` syntax:\r\n\r\n```elixir\r\n    # pushes 1 then 2 then performs adition\r\n    drex three        1 ~> 2 ~> Kernel.+/2\r\n\r\n    # pushes 2 then performs multiplication\r\n    # expecting a first value already on stack (ie. partial function)\r\n    drex double       Kernel.*/2 <~ 2\r\n```\r\n\r\n\r\nAs *operators* are the most frequent types of words you will be creating,\r\nthe following *concatenative* syntax is supported:\r\n\r\n```elixir\r\n    # This will multiply the second element on the stack\r\n    # and then print the final stack state to stdout.\r\n    drex double_second  swap double swap show\r\n```\r\n\r\nHowever, if you want to also push an integer or any other Elixir literal,\r\ntrying something like `3 double` wont work because its not valid Elixir syntax.\r\nBut you can use the `do` notation for `drex`:\r\n\r\n\r\n```elixir\r\n      drex sixsix do\r\n        3\r\n        double dup Kernel.*/2\r\n      end\r\n```\r\n\r\nis exactly the same as:\r\n\r\n```elixir\r\n      drex sixsix  3 ~> double ~> dup ~> Kernel.*/2\r\n```\r\n\r\nThe `do` form is peferred for large words. Most likely you'll just want to\r\nkeep them short as concatenative programs are very composable.\r\n\r\n#### [Pointless programming](https://en.wikipedia.org/wiki/Tacit_programming)\r\n\r\nWith Rex you can write point-free functions.\r\n\r\n```elixir\r\ndrex sumr     List.foldr/3 <~ (&Kernel.+/2) <~ 0\r\n\r\nassert [6] == sumr([1, 2, 3])\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}